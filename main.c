#include <stdio.h>
/*
Вот твой протокол Дима
1. 4 байта преамбула 
2. 1 байт N байт сообщения 
3. 1 байт адрес источника
4. 1 байт адрес приемника
5. Данные Н байт                                -- максимум 255
6. CRC - XOR всех байт сообщения включая преамбулу

Максимальное время сообщения 1 сек.

Написать прототипы функций для обработки протокола
Предоставить реализацию на С алгоритма приема сообщений протокола

Будь внимателен, восприми эту секунду как таймаут
*/
typedef enum{
FALSE=0,
TRUE=1
} boolean;

int timer_start_ms(int ms){
///считаем вниз
///устанавливаем счетчик таймер
///Перегрузку устанавливаем = 0
///стартуем счетчик таймер

}

int timer_stop(){
//останавливаем таймер
}

int timer_is_over(){
//если значение таймера 0 то 
 timer_stop();
    return 1;
    //иначе 
    return 0;
}



int bytes_available(){   //проверим доступность нового байта
//Читаем бит прерывания приемника например
};


int get_byte(){   //возвращает новый свежепринятый байт
//достаем из приемника пришедший байт
};



int get_packet(int resive_byte, int packet_buffer[]){ // смотрим на пришедший байт, принимаем решения
static int buf_cnt;
static int done_preabula_recive;
    static int preabula_byte;
    static const int preabula_size = 3;  //0123 это же 4??
static int done_adr_tx_recive;
static int done_adr_rx_recive;
static int done_message_recive;
    static int message_size;
    static int message_cnt;
static int done_crc_recive;


//1. 4 байта преамбула 
if(done_preabula_recive=0){    //принимаем преамбулу если не принята то принимаем.
    if(resive_byte==0x1){
        buf_cnt=0;     // инкрементируем счетчик буфера
        packet_buffer[buf_cnt]=resive_byte;
        buf_cnt++;
    }    
     if((resive_byte==0x2)&&(buf_cnt==1)){
        packet_buffer[buf_cnt]=resive_byte;
        buf_cnt++;
     }
      if((resive_byte==0x3)&&(buf_cnt==2)){
        packet_buffer[buf_cnt]=resive_byte;
        buf_cnt++;
     }    
      if((resive_byte==0x4)&&(buf_cnt==3)){
        packet_buffer[buf_cnt]=resive_byte;
        done_preabula_recive=1;                     //поднимаем флаг принятой преабулы
     }  
}


    //запускаем таймер таймаута
    //взводим флаг что приняли преамбулу
//2. 1 байт N байт сообщения
    //если таймаут то сбрасываем флаги принятия пакета
    //если принята преамбула принимаем адрес'
    //взводим флаг принятого адреса
//3. 1 байт адрес источника 
    //если таймаут то сбрасываем флаги принятия пакета
    //если принята размер сообщения принимаем адрес
    //взводим флаг принятого адреса источника
//4. 1 байт адрес приемника
    //если таймаут то сбрасываем флаги принятия пакета
    //если принята адрес источника принимаем адрес приемника
    //взводим флаг принятого адреса источника
//5.N байт приемника по 1 байт -- максимум 255
     //если таймаут то сбрасываем флаги принятия пакета
    //если принята адрес премника принимаем массив
    //получаем байт и инкрементируем принятый размер           
    //если размер принятого равен размеру данных то взводим флаг принятых данных
//6.//если таймаут то сбрасываем флаги принятия пакета
    //если принята   данных принимаем CRC
//7. CRC - XOR всех байт сообщения 
    //если приняты данные считаем СКС принятого пакета c адреса буфера, размером 4преамбула+1+1+1+N, с адресом адреса буфера + 4преамбула+1+1+1+N,
    //
    //если все переменные сошлись сверили возвращаем единицу


//добавить его к массиву
//проверить CRC
//ебнуть по таймауту
//
}

boolean packet_reaction(int packet_buffer[]){  //когда пакет принят его нужно бы засунуть в 
       return TRUE;  
};





int main()
{ 
 int packet_buffer[263]; //буфер 4+1+1+1+255+1

 if(bytes_available()){                                //если доступен новый байт
    if(get_packet(get_byte(), &packet_buffer))         //достаем его из приемника и формируем пакет
        packet_reaction(&packet_buffer);               //потом формируем его структуру
 }
};
